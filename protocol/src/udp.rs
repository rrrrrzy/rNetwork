// Copyright (C) 2025 rrrrrzy
// SPDX-License-Identifier: GPL-3.0-or-later
//
// --------------------------------------------------
// 致敬所有在深夜调试代码的灵魂。
// 即便 Bug 如山，我亦往矣。
// --------------------------------------------------
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.

use crate::{checksum::simple_checksum, error::UdpParseError, ipv4::Ipv4Addr};

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
struct FakeUdpHeader {
    src_ip: Ipv4Addr,
    dst_ip: Ipv4Addr,
    zero: u8,
    protocol: u8,
    length: u16, // length of totoal udp(Header + Payload)
}

impl FakeUdpHeader {
    fn new(src_ip: Ipv4Addr, dst_ip: Ipv4Addr, length: u16) -> Self {
        Self {
            src_ip,
            dst_ip,
            zero: 0,      // default 0
            protocol: 17, // default 17 (udp)
            length,
        }
    }

    fn to_bytes(&self) -> [u8; 12] {
        let mut bytes: [u8; 12] = [0; 12];
        bytes[0..4].copy_from_slice(&self.src_ip.octets());
        bytes[4..8].copy_from_slice(&self.dst_ip.octets());
        bytes[8] = self.zero;
        bytes[9] = self.protocol;
        bytes[10..12].copy_from_slice(&self.length.to_be_bytes());

        bytes
    }
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct UdpHeader {
    pub src_port: u16,
    pub dst_port: u16,
    pub length: u16, // length of totoal udp(Header + Payload)
    pub checksum: u16,
}

impl UdpHeader {
    pub fn new(src_port: u16, dst_port: u16, length: u16) -> Self {
        Self {
            src_port,
            dst_port,
            length,
            checksum: 0,
        }
    }

    pub fn to_bytes(&self) -> [u8; 8] {
        let mut bytes: [u8; 8] = [0; 8];
        bytes[0..2].copy_from_slice(&self.src_port.to_be_bytes());
        bytes[2..4].copy_from_slice(&self.dst_port.to_be_bytes());
        bytes[4..6].copy_from_slice(&self.length.to_be_bytes());
        bytes[6..8].copy_from_slice(&self.checksum.to_be_bytes());

        bytes
    }

    pub const fn len(&self) -> usize {
        8
    }
}

pub struct UdpPacket {
    pub header: UdpHeader,
    pub payload: Vec<u8>,
}

impl UdpPacket {
    pub fn new(
        mut header: UdpHeader,
        payload: Vec<u8>,
        src_ip: Ipv4Addr,
        dst_ip: Ipv4Addr,
    ) -> Self {
        let total_len = (header.len() + payload.len()) as u16;
        // Ensure header length matches actual payload length
        header.length = total_len;

        let fake_header = FakeUdpHeader::new(src_ip, dst_ip, total_len);

        let mut checksum_buffer = Vec::with_capacity(12 + 8 + payload.len());
        checksum_buffer.extend_from_slice(&fake_header.to_bytes()); // NOTICE: fakeudpheader is in front of others
        checksum_buffer.extend_from_slice(&header.to_bytes()); // Header with 0 checksum
        checksum_buffer.extend_from_slice(&payload);

        let mut checksum = simple_checksum(&checksum_buffer);
        if checksum == 0 {
            checksum = 0xFFFF;
        }

        let mut udp_packet = Self { header, payload };
        udp_packet.header.checksum = checksum;

        udp_packet
    }

    /// notice validate is not contained in parse
    pub fn parse(bytes: &[u8]) -> Result<Self, UdpParseError> {
        if bytes.len() < 8 {
            return Err(UdpParseError::InvalidUdpLen);
        }

        let src_port = u16::from_be_bytes([bytes[0], bytes[1]]);
        let dst_port = u16::from_be_bytes([bytes[2], bytes[3]]);
        let length = u16::from_be_bytes([bytes[4], bytes[5]]);
        let checksum = u16::from_be_bytes([bytes[6], bytes[7]]);

        let header = UdpHeader {
            src_port,
            dst_port,
            length,
            checksum,
        };

        // Validate length
        if bytes.len() < length as usize || length < 8 {
            return Err(UdpParseError::InvalidUdpLen);
        }

        // Extract payload
        // UDP length includes the header (8 bytes)
        let payload_len = length as usize - 8;
        let payload = bytes[8..8 + payload_len].to_vec();

        Ok(Self { header, payload })
    }

    pub fn to_bytes(&self) -> Vec<u8> {
        let header = self.header.to_bytes();
        let mut bytes = Vec::with_capacity(self.payload.len() + header.len());
        bytes.extend_from_slice(&header);
        bytes.extend_from_slice(&self.payload);

        bytes
    }

    #[allow(clippy::clone_on_copy)]
    pub fn validate(&self, src_ip: Ipv4Addr, dst_ip: Ipv4Addr) -> Result<(), UdpParseError> {
        // If checksum is 0, it means no checksum was generated by sender (IPv4 only)
        if self.header.checksum == 0 {
            return Ok(());
        }

        let total_len = (self.header.len() + self.payload.len()) as u16;
        let fake_header = FakeUdpHeader::new(src_ip, dst_ip, total_len);
        let mut checksum_header = self.header.clone();
        checksum_header.checksum = 0;

        let mut checksum_buffer = Vec::with_capacity(12 + 8 + self.payload.len());
        checksum_buffer.extend_from_slice(&fake_header.to_bytes()); // NOTICE: fakeudpheader is in front of others
        checksum_buffer.extend_from_slice(&checksum_header.to_bytes()); // Header with 0 checksum
        checksum_buffer.extend_from_slice(&self.payload);

        let mut checksum = simple_checksum(&checksum_buffer);
        if checksum == 0 {
            checksum = 0xFFFF;
        }

        if checksum == self.header.checksum {
            Ok(())
        } else {
            Err(UdpParseError::InvalidChecksum)
        }
    }
}
